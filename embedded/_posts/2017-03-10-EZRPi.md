---
title: EZRpi
header:
  teaser: /embedded/images/thumb/ezrpi.png
  image: /embedded/images/header/ezrpi.png
gallery-v1:
  - url: /embedded/images/full/schematic-v1.png
    image_path: /embedded/images/thumb/schematic-v1.png
    alt: "Schematic v1"
    title: "Schematic v1"
  - url: /embedded/images/full/board-v1.png
    image_path: /embedded/images/thumb/board-v1.png
    alt: "Board design v1"
    title: "Board design v1"
  - url: /embedded/images/full/ec-v1.png
    image_path: /embedded/images/thumb/ec-v1.png
    alt: "Rendering of board by EuroCircuits v1"
    title: "Rendering of board by EuroCircuits v1"  
---

EZRPi is a Raspberry Pi HAT with a Silicon Labs EZR32 Sub-GHz MCU. Using the EZRPi HAT one can have access to sub-GHz network protocols on a Raspberry Pi. 

An example of such protocol is Dash-7. Dash7 is a specification for an ultra low power network stack, operating within the sub-GHz spectrum. The [Dash7 Open Source Stack (OSS-7)](https://github.com/MOSAIC-LoPoW/dash7-ap-open-source-stack) can be flashed onto the EZR to turn it into a modem, accessible from the Raspberry Pi. On the Pi, one then could talk to this modem using [pyd7a](https://github.com/MOSAIC-LoPoW/pyd7a) a collection of Python modules, supporting the DASH7 Alliance Protocol in general, and OSS-7 in particular..

While [a GitHub repository](https://github.com/christophevg/EZRpi) contains all design and implementation source files of this generic sub-GHz Raspberry Pi HAT, on this page, I'm collecting overview & background information on the project, links to useful resources, remarks, wishes, angry screams,...

## Rationale

Having been working in the IoT space for almost three years now and being in love with creating new embedded devices for about two more years, I've already witnessed an incredible evolution. Every _thing_ is becoming connected, causing the WiFi space to become more and more _crowded_.

At certain locations the amount of wireless communication in the gigahertz range causes the network to become unreliable and even unusable for critical applications. People are looking at different solutions to get around this rising issue, looking for new _backbones_ for the ever increasing need for wireless communication.

As I've learned over the past years, the sub-GHz range of wireless communication might be a solution. While "classic" usage wants faster networks, for which people are looking at e,g, 5GHz, and beyond - 24GHz anyone? 60? - a great deal of applications don't require the vast amounts of data to be transmitted and rather require small amounts of data to be communicated. Certainly in the IoT space, where the _users_ are small devices with hardly video-streaming or other heavy downloading needs, looking at a slower, but possibly more reliable network might be a good solution to overcome the over-crowding of the _human_ space.

Sub-GHz network protocols, like Dash7, Z-Wave, SigFox, LoRaWAN,... offer lower data rates, but offer much longer range communication at a much lower energy cost. So besides not competing for _space_ in the 2.4 or 5 GHz frequency range, they come with additional bonus value.

Currently several break-out boards are popping up on the market, offering access to many of the mentioned networks. Still in its infancy, they all come with pros and cons, but most of the time all require an environment specific to their implementation in one way or the other. And although developing a network stack is surely not for the faint-of-heart, the underlying basics are doable even for enthousiasts.

The EZR32 by Silicon Labs is a microcontroller with a sub-GHz transceiver in a single package. It has everything on board to start talking and listening in this sub-GHz space.

With this project I want to create a generic solution to bring the sub-GHz range to Raspberry Pi, without focussing on one specific network stack.

With the EZR32 operating as a modem to the Raspberry Pi, the complexity of the network stack can be _hidden_ on the EZR, while using the network can be as simple as `send "hello world"` or `listen on 100.9MHz`.

Although this project is indifferent about network-technology, two demo implementations will be provided: the Dash7 Open Source Stack provides out-of-the box functionality to make the EZR32 operate as a modem, accessible through an `AT`-command set.

On the other hand, I want to implement a minimal and ultra-basic network "stack" to illustrate what is really needed to be able to make devices _talk_.

We'll see where this leads me :-)

## Version 1

The production of the first version of the board is currently ongoing. The design includes a standard 868MHz setup of the EZR32 and two LEDs for minimal debugging/feedback.

The board is a 2-layer PCB based on the official Raspberry Pi HAT board specification.

Within a few weeks both the components and prototype PCBs will be available and ready for (manual) soldering and testing.

{% include gallery id="gallery-v1"%}

### Schematic

The schematic is a verbatim implementation of what could be called a reference design, except for the fact that you have to bring together information from several resources.

* AN0002 - EFM32 and EZR32 hardware design considerations
* AN0016 - EFM32 oscillator design considerations
* AN627 - si4x6x and EZR32 low power pa matching

### Board Layout

A board layout with RF signals is not your average PCB and requires some special care. Basically you really _need to_ apply some best practices, that otherwise you could get away with. (With RF signals you _can_ get away with it also, but you'll loose performance and in RF terminology that means distance, and distance is what you'll probably want ;-))

> Some excellent general information on designing RF and Mixed signal boards can be found in [Maxim's tutorial 5100](https://www.maximintegrated.com/en/app-notes/index.mvp/id/5100). 

A few rules and their application I learned and applied:

#### Fast In & Outs

Try to keep traces as short as possible, or at least make sure they're _highways_.

* The entire bottom layer of the PCB is a ground plane. So with a simple via you can reach `GND` from (nearly) everywhere.
* The `VCC` traces are constructed as a star topology - in this case starting from the `VCC` pin on the HAT header branching out at the top-left corner of the occupied zone of the PCB - and are relatively wide.
* The ground plane beneath the MCU is connected to the ground plane on the bottom by means of _a lot_ of vias.
* The same goes for an additional ground plane on the top layer, around the antenna region. See below for more info on that.
* Where `GND` is needed, don't use traces to _join_ multiple `GND`-dependencies. Just use a via to go straight from every component to `GND`.

#### 50Ω & co

The traces going to the antenna are important. Their impedance needs to be (as close as possible to) 50Ω. Practically, this is needed for the last part, from the last inductor/capacitor on the right to the SMA connector itself.

To control the impedance, we need to calculate the width of the trace. There are some nice online calculators that help. Because I've added an additional top-layer ground plane around the antenna area, I've created a so called Coplanar Waveguide. In this case this allowed for a smaller trace width, which was needed because of the limited space between the `GND` pins of the SMA connector. Using one of the available [online calculators](http://chemandy.com/calculators/coplanar-waveguide-with-ground-calculator.htm), I was able to limit the width of the trace to 1.1mm, resulting in a 50,06Ω trace.

![Coplanar Waveguide 50Ω](images/full/coplanar-waveguide-50ohm.png)

Although there are already many vias connecting the top layer ground plane and the bottom layer ground plane, it is important to make sure that along the 50Ω trace, there are vias close-by, the so called via fences.

Good enough for now ;-)

_More to come ..._
